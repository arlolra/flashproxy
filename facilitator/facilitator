#!/usr/bin/env python

import SocketServer
import getopt
import os
import socket
import sys
import threading
import time

import fac

LISTEN_ADDRESS = "127.0.0.1"
DEFAULT_LISTEN_PORT = 9002
DEFAULT_RELAY_PORT = 9001
DEFAULT_LOG_FILENAME = "facilitator.log"

# Tell proxies to poll for clients every POLL_INTERVAL seconds.
POLL_INTERVAL = 600

# Don't indulge clients for more than this many seconds.
CLIENT_TIMEOUT = 1.0
# Buffer no more than this many bytes when trying to read a line.
READLINE_MAX_LENGTH = 10240

MAX_PROXIES_PER_CLIENT = 5

LOG_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

class UnknownTransport(Exception): pass

class options(object):
    listen_port = DEFAULT_LISTEN_PORT
    log_filename = DEFAULT_LOG_FILENAME
    log_file = sys.stdout
    relay_filename = None
    daemonize = True
    pid_filename = None
    privdrop_username = None
    safe_logging = True

    # Dictionary containing Tor relays that we can pass to
    # flashproxies. It looks like this:
    # {"websocket" : ["1.1.1.1:123"], "obfs3|websocket" : ["3.1.2.3:5555", "1.2.3.4:6666"], "obfs2|websocket" : ["1.2.4.4:5123"]}
    relays = {}

    @staticmethod
    def num_relays():
        """Return the number of registered relays."""

        num_relays = 0
        for relay_list in options.relays.values():
            num_relays += len(relay_list)

        return num_relays

    @staticmethod
    def add_relay(transport, spec):
        spec = fac.parse_addr_spec(spec, defport = DEFAULT_RELAY_PORT, resolve = True)
        options.relays.setdefault(transport, [])
        options.relays[transport].append(fac.format_addr(spec))

def usage(f = sys.stdout):
    print >> f, """\
Usage: %(progname)s -r RELAY <OPTIONS>
Flash proxy facilitator: Register client addresses and serve them out
again. Listen on 127.0.0.1 and port PORT (by default %(port)d).

  -d, --debug               don't daemonize, log to stdout.
  -h, --help                show this help.
  -l, --log FILENAME        write log to FILENAME (default \"%(log)s\").
  -p, --port PORT           listen on PORT (by default %(port)d).
      --pidfile FILENAME    write PID to FILENAME after daemonizing.
      --privdrop-user USER  switch UID and GID to those of USER.
  -r, --relay-file RELAY    learn relays from FILE.
      --unsafe-logging      don't scrub IP addresses from logs.\
""" % {
    "progname": sys.argv[0],
    "port": DEFAULT_LISTEN_PORT,
    "log": DEFAULT_LOG_FILENAME,
}

def parse_transport_chain(transport_chain):
    """
    Given a combined transport name in 'transport', return a tuple that
    contains the transport chain.
    e.g. if 'transport' == 'obfs3|websocket' we return (obfs3, websocket)
    """
    assert(transport_chain)
    # XXX We explicitly cast to tuple so that the return value can be
    # used as a dictionary key. Transport chains are not supposed to
    # be manipulated so it should be cool.
    return tuple(transport_chain.split("|"))

def get_outermost_transport(transport_chain):
    """
    Given a combined transport name in 'transport', return the name of
    the outermost transport.
    e.g. if 'transport' is (obfs3, websocket) this function returns 'websocket'
    """
    assert(transport_chain)
    return transport_chain[-1]

def safe_str(s):
    """Return "[scrubbed]" if options.safe_logging is true, and s otherwise."""
    if options.safe_logging:
        return "[scrubbed]"
    else:
        return s

log_lock = threading.Lock()
def log(msg):
    log_lock.acquire()
    try:
        print >> options.log_file, (u"%s %s" % (time.strftime(LOG_DATE_FORMAT), msg)).encode("UTF-8")
        options.log_file.flush()
    finally:
        log_lock.release()

class TCPReg(object):
    def __init__(self, host, port, transport_chain):
        """
        transport_chain: transport chain list. e.g. (obfs3, websocket)
        """
        self.host = host
        self.port = port
        self.transport_chain = transport_chain
        # Get a relay for this registration. Throw UnknownTransport if
        # could not be found.
        self.relay = self._get_matching_relay()

    def _get_matching_relay(self):
        """
        Return a matching relay addrspec for this registration

        Raise UnknownTransport if a relay with a matching transport
        chain could not be found.
        """
        if self.transport_chain not in options.relays:
            raise UnknownTransport("Can't find relay with transport chain: %s" % self.transport_chain)

        # Maybe this should be a random pick from the set of all the
        # eligible relays. But let's keep it deterministic for now,
        # and return the first one.

        # return random.choice(options.relays[self.transport_chain])
        return options.relays[self.transport_chain][0]

    def __unicode__(self):
        return fac.format_addr((self.host, self.port))

    def __str__(self):
        return unicode(self).encode("UTF-8")

    def __cmp__(self, other):
        if isinstance(other, TCPReg):
            # XXX is this correct comparison?
            return cmp((self.host, self.port, self.transport_chain), (other.host, other.port, other.transport_chain))
        else:
            return False

class Reg(object):
    @staticmethod
    def parse(spec, transport_chain, defhost = None, defport = None):
        host, port = fac.parse_addr_spec(spec, defhost, defport)
        return TCPReg(host, port, transport_chain)

class RegSet(object):
    def __init__(self):
        self.tiers = [[] for i in range(MAX_PROXIES_PER_CLIENT)]
        self.cv = threading.Condition()

    def add(self, reg):
        self.cv.acquire()
        try:
            for tier in self.tiers:
                if reg in tier:
                    break
            else:
                self.tiers[0].append(reg)
                self.cv.notify()
                return True
            return False
        finally:
            self.cv.release()

    def fetch(self):
        self.cv.acquire()
        try:
            for i in range(len(self.tiers)):
                tier = self.tiers[i]
                if tier:
                    reg = tier.pop(0)
                    if i + 1 < len(self.tiers):
                        self.tiers[i+1].append(reg)
                    return reg
            return None
        finally:
            self.cv.release()

    def __len__(self):
        self.cv.acquire()
        try:
            return sum(len(tier) for tier in self.tiers)
        finally:
            self.cv.release()

class Handler(SocketServer.StreamRequestHandler):
    def __init__(self, *args, **kwargs):
        self.deadline = time.time() + CLIENT_TIMEOUT
        # Buffer for readline.
        self.buffer = ""
        SocketServer.StreamRequestHandler.__init__(self, *args, **kwargs)

    def recv(self):
        timeout = self.deadline - time.time()
        self.connection.settimeout(timeout)
        return self.connection.recv(1024)

    def readline(self):
        # A line already buffered?
        i = self.buffer.find("\n")
        if i >= 0:
            line = self.buffer[:i+1]
            self.buffer = self.buffer[i+1:]
            return line

        auxbuf = []
        buflen = len(self.buffer)
        while True:
            data = self.recv()
            if not data:
                if self.buffer or auxbuf:
                    raise socket.error("readline: stream does not end with a newline")
                else:
                    return ""
            i = data.find("\n")
            if i >= 0:
                line = self.buffer + "".join(auxbuf) + data[:i+1]
                self.buffer = data[i+1:]
                return line
            else:
                auxbuf.append(data)
                buflen += len(data)
                if buflen >= READLINE_MAX_LENGTH:
                    raise socket.error("readline: refusing to buffer %d bytes (last read was %d bytes)" % (buflen, len(data)))

    @fac.catch_epipe
    def handle(self):
        num_lines = 0
        while True:
            try:
                line = self.readline()
                if not line:
                    break
                num_lines += 1
            except socket.error, e:
                log("socket error after reading %d lines: %s" % (num_lines, str(e)))
                break
            if not self.handle_line(line):
                break

    def handle_line(self, line):
        if not (len(line) > 0 and line[-1] == '\n'):
            raise ValueError("No newline at end of string returned by readline")
        try:
            command, params = fac.parse_transaction(line[:-1])
        except ValueError, e:
            log("fac.parse_transaction: %s" % e)
            self.send_error()
            return False

        if command == "GET":
            return self.do_GET(params)
        elif command == "PUT":
            return self.do_PUT(params)
        else:
            self.send_error()
            return False

    def send_ok(self):
        print >> self.wfile, "OK"

    def send_error(self):
        print >> self.wfile, "ERROR"

    # Handle a GET request (got flashproxy poll; need to return a proper client registration)
    # Example: GET FROM="3.3.3.3:3333" TRANSPORT="websocket" TRANSPORT="webrtc"
    def do_GET(self, params):
        proxy_spec = fac.param_first("FROM", params)
        if proxy_spec is None:
            log(u"GET missing FROM param")
            self.send_error()
            return False
        try:
            proxy_addr = fac.parse_addr_spec(proxy_spec, defport=0)
        except ValueError, e:
            log(u"syntax error in proxy address %s: %s" % (safe_str(repr(proxy_spec)), safe_str(repr(str(e)))))
            self.send_error()
            return False

        transport_list = fac.param_getlist("TRANSPORT", params)
        if not transport_list:
            log(u"TRANSPORT missing FROM param")
            self.send_error()
            return False

        try:
            reg = get_reg_for_proxy(proxy_addr, transport_list)
        except Exception, e:
            log(u"error getting reg for proxy address %s: %s" % (safe_str(repr(proxy_spec)), safe_str(repr(str(e)))))
            self.send_error()
            return False

        check_back_in = get_check_back_in_for_proxy(proxy_addr)

        if reg:
            log(u"proxy (%s) gets client '%s' (transport_chain: %s) (num relays: %s) (remaining regs: %d/%d)" %
                (safe_str(repr(proxy_spec)), safe_str(unicode(reg)), reg.transport_chain, options.num_relays(), num_unhandled_regs(), num_regs()))
            print >> self.wfile, fac.render_transaction("OK", ("CLIENT", str(reg)), ("RELAY", reg.relay), ("CHECK-BACK-IN", str(check_back_in)))
        else:
            log(u"proxy (%s) gets none" % safe_str(repr(proxy_spec)))
            print >> self.wfile, fac.render_transaction("NONE", ("CHECK-BACK-IN", str(check_back_in)))

        return True

    # Handle a PUT request (client made a registration request; register it.)
    # Example: PUT CLIENT="1.1.1.1:5555" FROM="1.1.1.2:6666" TRANSPORT_CHAIN="obfs3|websocket"
    def do_PUT(self, params):
        # Check out if we recognize the transport chain in this registration request
        transport_chain = fac.param_first("TRANSPORT_CHAIN", params)
        if transport_chain is None:
            log(u"PUT missing TRANSPORT_CHAIN param")
            self.send_error()
            return False

        # Turn the transport chain to tuple-form.
        transport_chain = parse_transport_chain(transport_chain)

        # See if we have relays that support this transport chain
        if transport_chain not in options.relays:
            log(u"Unrecognized transport chain: %s" % transport_chain)
            self.send_error() # XXX can we tell the flashproxy client of this error?
            return False
        # if we have relays that support this transport chain, we
        # certainly have a regset for its outermost transport too.
        assert(get_outermost_transport(transport_chain) in REGSETS_IPV4)

        client_spec = fac.param_first("CLIENT", params)
        if client_spec is None:
            log(u"PUT missing CLIENT param")
            self.send_error()
            return False

        try:
            reg = Reg.parse(client_spec, transport_chain)
        except (UnknownTransport, ValueError) as e:
            # XXX should we throw a better error message to the client? Is it possible?
            log(u"syntax error in %s: %s" % (safe_str(repr(client_spec)), safe_str(repr(str(e)))))
            self.send_error()
            return False

        try:
            ok = put_reg(reg)
        except Exception, e:
            log(u"error putting reg %s: %s" % (safe_str(repr(client_spec)), safe_str(repr(str(e)))))
            self.send_error()
            return False

        if ok:
            log(u"client %s (transports: %s) (remaining regs: %d/%d)" % (safe_str(unicode(reg)), reg.transport_chain, num_unhandled_regs(), num_regs()))
        else:
            log(u"client %s (already present) (transports: %s) (remaining regs: %d/%d)" % (safe_str(unicode(reg)), reg.transport_chain, num_unhandled_regs(), num_regs()))

        self.send_ok()
        return True

    finish = fac.catch_epipe(SocketServer.StreamRequestHandler.finish)

class Server(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    allow_reuse_address = True

# Registration sets per-outermost-transport
# {"websocket" : <RegSet for websocket>, "webrtc" : <RegSet for webrtc>}
REGSETS_IPV4 = {}
REGSETS_IPV6 = {}

def num_regs():
    """Return the total number of registrations."""
    num_regs = 0

    # Iterate the regsets of each regset-dictionary, and count their
    # registrations.
    for regset in REGSETS_IPV4.values():
        num_regs += len(regset)
    for regset in REGSETS_IPV6.values():
        num_regs += len(regset)

    return num_regs

def num_unhandled_regs():
    """Return the total number of unhandled registrations."""
    num_regs = 0

    # Iterate the regsets of each regset-dictionary, and count their
    # unhandled registrations. The first tier of each regset contains
    # the registrations with no assigned proxy.
    for regset in REGSETS_IPV4.values():
        num_regs += len(regset.tiers[0])
    for regset in REGSETS_IPV6.values():
        num_regs += len(regset.tiers[0])

    return num_regs

def get_regs(af, transport):
    """Return the correct regs pool for the given address family and transport."""
    if transport not in REGSETS_IPV4:
        raise UnknownTransport("unknown transport '%s'" % transport)

    if af == socket.AF_INET:
        return REGSETS_IPV4[transport]
    elif af == socket.AF_INET6:
        return REGSETS_IPV6[transport]
    else:
        raise ValueError("unknown address family %d" % af)

def addr_af(addr_str):
    """Return the address family for an address string. This is a plain string,
    not a tuple, and IPv6 addresses are not bracketed."""
    addrs = socket.getaddrinfo(addr_str, 0, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_NUMERICHOST)
    return addrs[0][0]

def get_reg_for_proxy(proxy_addr, transport_list):
    """Get a client registration appropriate for the given proxy (one
    of a matching address family). If 'transports' is set, try to find
    a client registration that supports the outermost transport of a
    transport chain."""
    # XXX How should we prioritize transport matching? We currently
    # just iterate the transport list that was provided by the flashproxy
    for transport in transport_list:
        addr_str = proxy_addr[0]
        af = addr_af(addr_str)

        try:
            REGS = get_regs(af, transport)
        except UnknownTransport as e:
            log(u"%s" % e)
            continue # move to the next transport

        return REGS.fetch()

    raise UnknownTransport("Could not find registration for transport list: %s" % str(transport_list))

def get_check_back_in_for_proxy(proxy_addr):
    """Get a CHECK-BACK-IN interval suitable for this proxy."""
    return POLL_INTERVAL

def put_reg(reg):
    """Add a registration."""
    addr_str = reg.host
    af = addr_af(addr_str)
    REGS = get_regs(af, get_outermost_transport(reg.transport_chain))
    return REGS.add(reg)

def handle_relay_file(fname):
    """
    Parse a file containing Tor relays that we can point proxies to.
    Throws ValueError if the file is not properly formatted.
    """
    # File format is:
    #  <transport> <addrport>
    # Example:
    #  obfs2|websocket 1.4.6.1:4123
    with open(fname) as input:
        for line in input:
            words_list = line.split()
            if len(words_list) != 2:
                raise ValueError("Wrong line format: %s" % line)

            # XXX Maybe we should validate here
            options.add_relay(parse_transport_chain(words_list[0]), words_list[1])

def main():
    opts, args = getopt.gnu_getopt(sys.argv[1:], "dhl:p:r:",
        ["debug", "help", "log=", "port=", "pidfile=", "privdrop-user=", "relay-file=", "unsafe-logging"])
    for o, a in opts:
        if o == "-d" or o == "--debug":
            options.daemonize = False
            options.log_filename = None
        elif o == "-h" or o == "--help":
            usage()
            sys.exit()
        elif o == "-l" or o == "--log":
            options.log_filename = a
        elif o == "-p" or o == "--port":
            options.listen_port = int(a)
        elif o == "--pidfile":
            options.pid_filename = a
        elif o == "--privdrop-user":
            options.privdrop_username = a
        elif o == "-r" or o == "--relay-file":
            options.relay_filename = a
        elif o == "--unsafe-logging":
            options.safe_logging = False

    if not options.relay_filename:
        print >> sys.stderr, """\
The -r option is required. Give it the name of a file
containing relay transports and addresses.
  -r HOST[:PORT]
Example file contents:
obfs2|websocket 1.4.6.1:4123\
"""
        sys.exit(1)

    handle_relay_file(options.relay_filename)

    if not options.relays:
        print >> sys.stderr, u"Warning: no relays configured."

    # Create RegSets for our supported transports
    for transport in options.relays.keys():
        outermost_transport = get_outermost_transport(transport)
        if outermost_transport not in REGSETS_IPV4:
            REGSETS_IPV4[outermost_transport] = RegSet()
            REGSETS_IPV6[outermost_transport] = RegSet()

    # Setup log file
    if options.log_filename:
        options.log_file = open(options.log_filename, "a")
        # Send error tracebacks to the log.
        sys.stderr = options.log_file
    else:
        options.log_file = sys.stdout

    addrinfo = socket.getaddrinfo(LISTEN_ADDRESS, options.listen_port, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP)[0]

    server = Server(addrinfo[4], Handler)

    log(u"start on %s" % fac.format_addr(addrinfo[4]))
    log(u"using relays %s" % str(options.relays))

    if options.daemonize:
        log(u"daemonizing")
        pid = os.fork()
        if pid != 0:
            if options.pid_filename:
                f = open(options.pid_filename, "w")
                print >> f, pid
                f.close()
            sys.exit(0)

    if options.privdrop_username is not None:
        log(u"dropping privileges to those of user %s" % options.privdrop_username)
        try:
            fac.drop_privs(options.privdrop_username)
        except BaseException, e:
            print >> sys.stderr, "Can't drop privileges:", str(e)
            sys.exit(1)

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == "__main__":
    main()

